module Demux_1_8(i, s, y);
    input i;                // Input signal
    input [2:0] s;          // 3-bit select signal
    output reg [7:0] y;     // 8-bit output, declared as a reg because it's assigned in an always block

    always @(i or s) begin
        case(s)
            3'b000: y = i ? 8'b00000001 : 8'b00000000;
            3'b001: y = i ? 8'b00000010 : 8'b00000000;
            3'b010: y = i ? 8'b00000100 : 8'b00000000;
            3'b011: y = i ? 8'b00001000 : 8'b00000000;
            3'b100: y = i ? 8'b00010000 : 8'b00000000;
            3'b101: y = i ? 8'b00100000 : 8'b00000000;
            3'b110: y = i ? 8'b01000000 : 8'b00000000;
            3'b111: y = i ? 8'b10000000 : 8'b00000000;
            default: y = 8'b00000000;  // Default case to handle unexpected values of s
        endcase
    end
endmodule
module Demux_1_8_tb();
    reg i;
    reg [2:0] s;
    wire [7:0] y;

    Demux_1_8 u1 (i, s, y);

    initial begin 
        #0  i = 1'b1;
        #10 s = 3'b000;
        #10 s = 3'b001;
        #10 s = 3'b010;
        #10 s = 3'b011;
        #10 s = 3'b100;
        #10 s = 3'b101;
        #10 s = 3'b110;
        #10 s = 3'b111;
        #10 $finish;
    end

    initial begin
        $monitor($time, " i=%b, s=%b, y=%b", i, s, y);
    end
endmodule

